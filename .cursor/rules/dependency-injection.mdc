---
description: 
globs: 
alwaysApply: true
---
# Dependency Injection Guide (Simple)

This project uses Uber FX for dependency injection. The goal is to keep DI simple, clear, and maintainable.

## Core Principles

1. **Use fx.Provide for all injectable components.**
2. **Use fx.In for grouping dependencies only when it improves clarity.**
3. **Use fx.Out only when a constructor must provide multiple values.**
4. **Use fx.Annotate and fx.As only when interface casting or grouping is needed.**
5. **Add error handling for fx.Provide functions.**
6. **Add OnStart/OnStop hooks only for components that need resource management.**
7. **Group related providers in modules, but avoid unnecessary modules.**
8. **Use clear, descriptive names for modules and providers.**
9. **Keep interface decoupling simple: use fx.As only when needed.**

## Example Patterns

### Single Provider
```go
fx.Provide(NewUserService)
```

### Grouped Dependencies (fx.In)
```go
type HandlerDeps struct {
    fx.In
    UserService user.Service
    Logger      logging.Logger
}
```

### Multiple Outputs (fx.Out)
```go
type Stores struct {
    fx.Out
    UserStore user.Repository
    FormStore form.Repository
}

func NewStores(db *database.GormDB, logger logging.Logger) Stores {
    return Stores{
        UserStore: userstore.NewStore(db, logger),
        FormStore: formstore.NewStore(db, logger),
    }
}
```

### Interface Casting (fx.Annotate, fx.As)
```go
fx.Provide(
    fx.Annotate(
        NewUserService,
        fx.As(new(user.Service)),
    ),
)
```

### Lifecycle Hooks
```go
fx.Provide(
    func(lc fx.Lifecycle) (*Resource, error) {
        r := &Resource{}
        lc.Append(fx.Hook{
            OnStart: func(ctx context.Context) error {
                return r.Start()
            },
            OnStop: func(ctx context.Context) error {
                return r.Stop()
            },
        })
        return r, nil
    },
)
```

## Best Practices
- Avoid global variables and init() for DI
- Prefer explicit, constructor-based injection
- Only use advanced FX features when necessary
- Keep modules and providers as simple as possible
- Document any non-obvious DI patterns
