---
description: 
globs: 
alwaysApply: true
---
# Dependency Injection Guide

This guide outlines the best practices for dependency injection in the GoFormX application.

## Database Dependencies

### GORM Database

1. Use the GORM database connection:
   ```go
   type Store struct {
       db *database.GormDB
   }
   
   func NewStore(db *database.GormDB) *Store {
       return &Store{db: db}
   }
   ```

2. Configure the database in the infrastructure module:
   ```go
   func NewInfrastructureModule() fx.Option {
       return fx.Module("infrastructure",
           fx.Provide(
               config.New,
               logging.NewFactory,
               database.NewGormDB,
               NewStores,
           ),
       )
   }
   ```

3. Use dependency injection for database operations:
   ```go
   func NewStores(db *database.GormDB, logger logging.Logger) (
       user.Repository,
       form.Repository,
       form.SubmissionStore,
   ) {
       return userstore.NewStore(db, logger),
           formstore.NewStore(db, logger),
           formsubmission.NewStore(db, logger)
   }
   ```

## Best Practices

1. Use constructor injection
2. Keep dependencies explicit
3. Use interfaces for better testability
4. Follow the dependency inversion principle
5. Use fx for dependency injection
6. Keep configuration close to the infrastructure layer
7. Use proper error handling
8. Implement proper logging
9. Use context for cancellation and timeouts
10. Keep dependencies minimal

## Module Structure
Each domain area should have its own module.go file:
```go
fx.Module("domain", 
  fx.Provide(
    NewService,
    NewRepository,
  ),
  fx.Invoke(
    RegisterHandlers,
  ),
)
```

## Component Guidelines

### Service Components
1. Define interfaces in domain layer
2. Implement in infrastructure layer
3. Use fx.Annotate for interface bindings
4. Provide clear lifecycle hooks

### Repository Components
1. Define interfaces in domain layer
2. Implement in infrastructure layer
3. Use proper connection pooling
4. Handle transactions appropriately

### Handler Components
1. Register routes in fx.Invoke
2. Use echo.Context
3. Implement proper validation
4. Return consistent responses

## Example Modules

### Infrastructure Module
```go
fx.Module("infrastructure",
  fx.Provide(
    config.New,
    database.NewDB,
    func(db *database.Database) *sqlx.DB {
        return db.DB
    },
    fx.Annotate(
        userstore.NewStore,
        fx.As(new(user.Store)),
    ),
    fx.Annotate(
        formstore.NewStore,
        fx.As(new(form.Store)),
    ),
    func(logger logging.Logger) *appmiddleware.SessionManager {
        return appmiddleware.NewSessionManager(logger)
    },
    func(
        core CoreParams,
        services ServiceParams,
        sessionManager *appmiddleware.SessionManager,
    ) *appmiddleware.Manager {
        return appmiddleware.New(&appmiddleware.ManagerConfig{
            Logger:         core.Logger,
            Security:       &core.Config.Security,
            UserService:    services.UserService,
            SessionManager: sessionManager,
            Config:         core.Config,
        })
    },
  ),
)
```

### Handler Module
```go
fx.Module("handlers",
  fx.Provide(
    AnnotateHandler(func(core CoreParams, services ServiceParams) *wh.DemoHandler {
        return wh.NewDemoHandler(core.Logger, core.Renderer, services.SubscriptionService)
    }),
  ),
)
```
