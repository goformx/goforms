---
description: 
globs: internal/infrastructure/**/*.go
alwaysApply: false
---
# Infrastructure Module Guide

This guide outlines the best practices for implementing the infrastructure module in the GoFormX application.

## Core Structure

The main infrastructure module is defined in [internal/infrastructure/module.go](mdc:goforms/goforms/internal/infrastructure/module.go) and follows a modular design pattern using the `fx` dependency injection framework.

### Module Organization

The module is split into focused sub-modules:

1. `InfrastructureModule`: Core infrastructure dependencies
   ```go
   var InfrastructureModule = fx.Options(
       fx.Provide(
           // Core infrastructure
           config.New,
           database.NewDB,  // Database connection belongs in infrastructure
           logging.NewFactory,
           validation.New,
           
           // Middleware
           func(logger logging.Logger) *appmiddleware.SessionManager {
               return appmiddleware.NewSessionManager(logger)
           },
           func(
               core CoreParams,
               services ServiceParams,
               sessionManager *appmiddleware.SessionManager,
           ) *appmiddleware.Manager {
               return appmiddleware.New(&appmiddleware.ManagerConfig{
                   Logger:         core.Logger,
                   Security:       &core.Config.Security,
                   UserService:    services.UserService,
                   SessionManager: sessionManager,
                   Config:         core.Config,
               })
           },
       ),
   )
   ```

2. `HandlerModule`: HTTP handlers and routing

## What Belongs in Infrastructure

The infrastructure layer should only contain:

1. Core Infrastructure Components:
   - Database connections and connection management
   - Logging
   - Configuration
   - Event system
   - Middleware
   - Server setup
   - Validation

2. External Service Adapters:
   - Message queue clients
   - Cache implementations
   - External API clients

3. Technical Concerns:
   - Connection pooling
   - Resource management
   - Error handling
   - Logging infrastructure

## What Does NOT Belong in Infrastructure

The following should be moved to their respective layers:

1. Application Services:
   - Auth service → application layer
   - User service → application layer
   - Form service → application layer

2. Presentation Components:
   - View renderers → presentation layer
   - Template engines → presentation layer
   - UI components → presentation layer

3. Domain Logic:
   - Business rules → domain layer
   - Domain services → domain layer
   - Domain events → domain layer
   - Repositories and stores → domain layer
   - Repository implementations → domain layer

## Handler Registration

Handlers should be registered using the `AnnotateHandler` helper function:

```go
AnnotateHandler(func(core CoreParams, services ServiceParams) *wh.DemoHandler {
    return wh.NewDemoHandler(core.Logger, core.Renderer, services.SubscriptionService)
})
```

### Parameter Organization

Handler dependencies are organized into focused parameter groups:

1. `CoreParams`: Infrastructure dependencies (logging, rendering, config)
2. `ServiceParams`: Business service dependencies

This separation keeps dependencies organized and maintainable.

## Store Management

Store initialization follows these principles:

1. Early validation of database connection
2. Explicit nil checks for each store
3. Detailed error logging with context
4. Type safety through Go's type system
5. **Stores are defined and initialized in the domain layer**

Example store initialization in domain layer:
```go
// In domain/module.go
type StoreParams struct {
    fx.In
    DB     *database.GormDB  // Database connection from infrastructure
    Logger logging.Logger    // Logger from infrastructure
}

func NewStores(p StoreParams) (Stores, error) {
    if p.DB == nil {
        return Stores{}, errors.New("database connection is required")
    }

    userStore := userstore.NewStore(p.DB, p.Logger)
    formStore := formstore.NewStore(p.DB, p.Logger)
    if userStore == nil || formStore == nil {
        p.Logger.Error("failed to create store",
            "operation", "store_initialization",
            "store_type", "user/form",
            "error_type", "nil_store",
        )
        return Stores{}, fmt.Errorf("failed to create user or form store")
    }

    return Stores{
        UserStore: userStore,
        FormStore: formStore,
    }, nil
}
```

## Error Handling

The module follows these error handling principles:

1. Fail fast - return errors immediately when detected
2. Provide detailed error context
3. Use structured logging for errors
4. Ensure proper cleanup on failure

## Logging Guidelines

Logging should:

1. Include operation context
2. Use appropriate log levels:
   - Error: For failures
   - Info: For successful operations
   - Debug: For detailed process information
3. Include relevant metadata:
   - Operation name
   - Store/handler types
   - Error types
   - Component status

## Best Practices

1. Use dependency injection for better testability
2. Keep modules focused and single-purpose
3. Provide clear error messages
4. Use structured logging
5. Implement proper error handling
6. Ensure type safety
7. Follow fail-fast principle
8. Use proper logging levels
9. Use interface embedding for logger compatibility
10. Keep configuration validation close to the config package

## Database Operations

### GORM Usage

1. Use GORM for all database operations:
   ```go
   // Example of using GORM for database operations
   func (s *Store) Create(ctx context.Context, u *user.User) error {
       result := s.db.WithContext(ctx).Create(u)
       if result.Error != nil {
           return fmt.Errorf("failed to create user: %w", result.Error)
       }
       return nil
   }
   ```

2. Always use context-aware methods:
   ```go
   // Good
   s.db.WithContext(ctx).Where("email = ?", email).First(&u)
   
   // Bad
   s.db.Where("email = ?", email).First(&u)
   ```

3. Use transactions when needed:
   ```go
   func (s *Store) CreateWithTransaction(ctx context.Context, u *user.User) error {
       return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
           if err := tx.Create(u).Error; err != nil {
               return err
           }
           // Additional operations within the same transaction
           return nil
       })
   }
   ```

4. Handle errors appropriately:
   ```go
   if err := s.db.WithContext(ctx).First(&u, id).Error; err != nil {
       if errors.Is(err, gorm.ErrRecordNotFound) {
           return nil, ErrUserNotFound
       }
       return nil, fmt.Errorf("failed to get user: %w", err)
   }
   ```

### Connection Management

1. Use the provided database connection:
   ```go
   type Store struct {
       db *database.GormDB
   }
   
   func NewStore(db *database.GormDB) *Store {
       return &Store{db: db}
   }
   ```

2. Configure connection pool settings:
   ```go
   sqlDB, err := db.DB()
   if err != nil {
       return nil, fmt.Errorf("failed to get database instance: %w", err)
   }
   
   sqlDB.SetMaxOpenConns(cfg.Database.Postgres.MaxOpenConns)
   sqlDB.SetMaxIdleConns(cfg.Database.Postgres.MaxIdleConns)
   sqlDB.SetConnMaxLifetime(cfg.Database.Postgres.ConnMaxLifetime)
   ```

### Error Handling

1. Define custom errors:
   ```go
   var (
       ErrUserNotFound = errors.New("user not found")
       ErrInvalidInput = errors.New("invalid input")
   )
   ```

2. Wrap errors with context:
   ```go
   if err := s.db.WithContext(ctx).Create(u).Error; err != nil {
       return fmt.Errorf("failed to create user: %w", err)
   }
   ```

### Logging

1. Use structured logging:
   ```go
   logger.Debug("creating user",
       logging.StringField("email", u.Email),
       logging.StringField("id", u.ID),
   )
   ```

2. Log errors with context:
   ```go
   logger.Error("failed to create user",
       logging.ErrorField("error", err),
       logging.StringField("email", u.Email),
   )
   ```

## Best Practices

1. Keep database operations in the domain layer
2. Use dependency injection for database connections
3. Implement proper error handling and logging
4. Use transactions for operations that require atomicity
5. Follow the repository pattern for data access
6. Use context for cancellation and timeouts
7. Implement proper connection pooling
8. Use GORM's built-in features for common operations
9. Keep SQL queries maintainable and readable
10. Use proper indexing for performance
