---
description: 
globs: internal/**/*_test.go
alwaysApply: false
---
# Testing Guidelines

## Test Types

1. **Unit Tests**
   - Test domain logic
   - Use table-driven tests
   - Mock dependencies

2. **Integration Tests**
   - Test API endpoints
   - Test database operations
   - Use testcontainers

## Test Structure

1. **Table-Driven Tests**
   ```go
   func TestValidation(t *testing.T) {
       tests := []struct {
           name    string
           input   string
           wantErr bool
       }{
           {"valid", "test@example.com", false},
           {"invalid", "invalid", true},
       }
   
       for _, tt := range tests {
           t.Run(tt.name, func(t *testing.T) {
               err := validate(tt.input)
               require.Equal(t, tt.wantErr, err != nil)
           })
       }
   }
   ```

2. **Error Testing**
   ```go
   t.Run("error case", func(t *testing.T) {
       err := someFunction()
       require.Error(t, err)
       assert.ErrorIs(t, err, expectedError)
   })
   ```

## Best Practices

1. **Setup**
   - Use `t.Context()`
   - Clean up resources
   - Mock external services

2. **Assertions**
   - Use `require` for critical checks
   - Use `assert` for non-critical checks
   - Test error cases

3. **Cleanup**
   ```go
   func TestDB(t *testing.T) {
       db, err := setupDB()
       require.NoError(t, err)
       defer db.Close()
       // ... test ...
   }
   ```

## Common Patterns

1. **Mocking**
   ```go
   type MockStore struct {
       mock.Mock
   }
   
   func (m *MockStore) Create(ctx context.Context, user *User) error {
       args := m.Called(ctx, user)
       return args.Error(0)
   }
   ```

2. **Test Helpers**
   ```go
   func setupTestDB(t *testing.T) *sql.DB {
       db, err := sql.Open("postgres", testDBURL)
       require.NoError(t, err)
       return db
   }
   ```
