---
description: 
globs: 
alwaysApply: true
---
# Architecture Guidelines

This project follows a clean architecture pattern with clear separation of concerns and well-defined boundaries.

## Core Architecture

1. **Domain Layer**
   - Core business logic
   - Domain models
   - Domain events
   - Domain services
   - Repository interfaces

2. **Application Layer**
   - Use cases
   - Service implementations
   - Command/Query handlers
   - Event handlers
   - Validation

3. **Infrastructure Layer**
   - Repository implementations
   - External services
   - Database access
   - Message queues
   - Caching

4. **Interface Layer**
   - HTTP handlers
   - API endpoints
   - Web interfaces
   - Authentication
   - Authorization

## Directory Structure

```
internal/
├── domain/           # Domain layer
│   ├── common/       # Shared domain code
│   ├── form/         # Form domain
│   └── user/         # User domain
├── application/      # Application layer
│   ├── services/     # Service implementations
│   └── handlers/     # Command/Query handlers
├── infrastructure/   # Infrastructure layer
│   ├── persistence/  # Database access
│   ├── messaging/    # Message queues
│   └── cache/        # Caching
└── interfaces/       # Interface layer
    ├── http/         # HTTP handlers
    ├── api/          # API endpoints
    └── web/          # Web interfaces
```

## Design Principles

1. **Clean Architecture**
   - Dependencies point inward
   - Domain layer is independent
   - Infrastructure adapts to domain
   - Interfaces adapt to application

2. **Domain-Driven Design**
   - Rich domain models
   - Ubiquitous language
   - Bounded contexts
   - Aggregate roots

3. **SOLID Principles**
   - Single Responsibility
   - Open/Closed
   - Liskov Substitution
   - Interface Segregation
   - Dependency Inversion

4. **Event-Driven Design**
   - Domain events
   - Event handlers
   - Event sourcing
   - CQRS

## Implementation Guidelines

1. **Domain Models**
   ```go
   type Form struct {
       ID          string    `json:"id"`
       UserID      uint      `json:"user_id"`
       Title       string    `json:"title"`
       Description string    `json:"description"`
       Schema      JSON      `json:"schema"`
       Active      bool      `json:"active"`
       CreatedAt   time.Time `json:"created_at"`
       UpdatedAt   time.Time `json:"updated_at"`
   }
   ```

2. **Repository Interfaces**
   ```go
   type Repository interface {
       Create(ctx context.Context, form *model.Form) error
       GetByID(ctx context.Context, id string) (*model.Form, error)
       GetByUserID(ctx context.Context, userID uint) ([]*model.Form, error)
       Update(ctx context.Context, form *model.Form) error
       Delete(ctx context.Context, id string) error
   }
   ```

3. **Domain Services**
   ```go
   type Service interface {
       CreateForm(ctx context.Context, userID uint, title, description string, schema model.JSON) (*model.Form, error)
       GetForm(ctx context.Context, id string) (*model.Form, error)
       GetUserForms(ctx context.Context, userID uint) ([]*model.Form, error)
       UpdateForm(ctx context.Context, form *model.Form) error
       DeleteForm(ctx context.Context, id string) error
   }
   ```

4. **Event Handlers**
   ```go
   type EventHandler interface {
       Handle(ctx context.Context, event Event) error
   }
   ```

## Best Practices

1. **Dependency Injection**
   - Use constructor injection
   - Define clear interfaces
   - Use dependency containers
   - Avoid service locators

2. **Error Handling**
   - Use domain-specific errors
   - Handle errors at boundaries
   - Include error context
   - Maintain error chain

3. **Validation**
   - Validate at boundaries
   - Use value objects
   - Implement business rules
   - Return clear errors

4. **Testing**
   - Unit test domain logic
   - Integration test services
   - End-to-end test flows
   - Mock external dependencies
