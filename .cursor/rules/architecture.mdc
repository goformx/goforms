---
description: 
globs: 
alwaysApply: true
---
# Architecture Guidelines

## Overview
The application follows a layered architecture with clear separation of concerns. The codebase is organized into four main layers: domain, application, infrastructure, and presentation.

## Directory Structure

```
internal/
├── domain/           # Domain layer
│   ├── common/       # Shared domain code
│   ├── form/         # Form domain
│   └── user/         # User domain
├── application/      # Application layer
│   ├── handlers/     # HTTP handlers
│   ├── middleware/   # HTTP middleware
│   └── response/     # Response handling
├── infrastructure/   # Infrastructure layer
│   ├── config/       # Configuration
│   ├── database/     # Database access
│   └── logging/      # Logging
└── presentation/     # Presentation layer
    ├── templates/    # HTML templates
    └── view/         # View rendering
```

## Core Components

1. Domain Layer
   - Models and business logic
   - Service interfaces
   - Repository interfaces
   - Example:
   ```go
   type Service interface {
       CreateForm(ctx context.Context, userID string, form *model.Form) error
       GetForm(ctx context.Context, id string) (*model.Form, error)
       GetUserForms(ctx context.Context, userID string) ([]*model.Form, error)
       UpdateForm(ctx context.Context, userID string, form *model.Form) error
       DeleteForm(ctx context.Context, userID, id string) error
   }
   ```

2. Application Layer
   - HTTP handlers
   - Middleware
   - Response handling
   - Example:
   ```go
   type Handler interface {
       Register(e *echo.Echo)
       Start(ctx context.Context) error
       Stop(ctx context.Context) error
   }
   ```

3. Infrastructure Layer
   - Configuration
   - Database access
   - Logging
   - Example:
   ```go
   type Config struct {
       App      AppConfig
       Database DatabaseConfig
       Security SecurityConfig
       // ... other configs
   }
   ```

4. Presentation Layer
   - HTML templates
   - View rendering
   - Example:
   ```go
   type Renderer interface {
       Render(c echo.Context, template Template) error
   }
   ```

## Best Practices

1. Dependency Management
   - Use dependency injection
   - Define clear interfaces
   - Validate dependencies
   - Example:
   ```go
   type HandlerDeps struct {
       Logger            logging.Logger
       Config            *config.Config
       SessionManager    *session.Manager
       MiddlewareManager *middleware.Manager
       Renderer          view.Renderer
       UserService       user.Service
       FormService       form.Service
   }
   ```

2. Error Handling
   - Use domain errors
   - Log errors with context
   - Return appropriate responses
   - Example:
   ```go
   if err != nil {
       h.Logger.Error("failed to get form", "error", err)
       return response.WebErrorResponse(c, h.Renderer, http.StatusNotFound, "Form not found")
   }
   ```

3. Configuration
   - Use environment variables
   - Validate configuration
   - Provide defaults
   - Example:
   ```go
   type AppConfig struct {
       Name    string `env:"GOFORMS_APP_NAME" envDefault:"GoForms"`
       Version string `env:"GOFORMS_APP_VERSION" envDefault:"dev"`
       Env     string `env:"GOFORMS_APP_ENV" envDefault:"development"`
   }
   ```

4. Logging
   - Use structured logging
   - Include context
   - Use appropriate levels
   - Example:
   ```go
   h.Logger.Error("failed to get form",
       "form_id", formID,
       "error", err,
   )
   ```
