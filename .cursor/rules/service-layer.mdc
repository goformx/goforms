---
description: 
globs: internal/**/services/**/*.go
alwaysApply: false
---
# Service Layer Architecture

## Overview
The service layer implements domain-specific business logic with clear separation of concerns. Services are organized by domain (form, user, etc.) and follow a consistent pattern.

## Core Components

1. Service Interface
   - Defined in domain package
   - Focused on business operations
   - Clear method signatures
   - Example from form service:
   ```go
   type Service interface {
       CreateForm(ctx context.Context, userID string, form *model.Form) error
       GetForm(ctx context.Context, id string) (*model.Form, error)
       GetUserForms(ctx context.Context, userID string) ([]*model.Form, error)
       UpdateForm(ctx context.Context, userID string, form *model.Form) error
       DeleteForm(ctx context.Context, userID, id string) error
   }
   ```

2. Service Implementation
   - Private struct with dependencies
   - Constructor function
   - Consistent error handling
   - Example:
   ```go
   type service struct {
       repo      Repository
       publisher event.Publisher
       logger    logging.Logger
   }

   func NewService(repo Repository, publisher event.Publisher, logger logging.Logger) *service {
       return &service{
           repo:      repo,
           publisher: publisher,
           logger:    logger,
       }
   }
   ```

## Best Practices

1. Error Handling
   - Use domain error codes
   - Provide context in errors
   - Log errors with details
   - Example:
   ```go
   if err := form.Validate(); err != nil {
       logger.Error("form validation failed", "error", err)
       return domainerrors.New(domainerrors.ErrCodeInvalidInput, "create form: invalid input", err)
   }
   ```

2. Input Validation
   - Sanitize user input
   - Validate domain rules
   - Check permissions
   - Example:
   ```go
   form.Title = sanitize.XSS(form.Title)
   form.Description = sanitize.XSS(form.Description)
   if err := form.Validate(); err != nil {
       // Handle error
   }
   ```

3. Event Publishing
   - Publish domain events
   - Handle publish errors
   - Log failures
   - Example:
   ```go
   if pubErr := s.publisher.Publish(ctx, event.NewFormCreatedEvent(form)); pubErr != nil {
       logger.Error("failed to publish form created event", "error", pubErr)
   }
   ```

4. Context Usage
   - Pass context through
   - Set timeouts
   - Cancel operations
   - Example:
   ```go
   ctx, cancel := context.WithTimeout(ctx, DefaultTimeout)
   defer cancel()
   ```

5. Logging
   - Use structured logging
   - Include user context
   - Log at appropriate levels
   - Example:
   ```go
   logger := s.logger.WithUserID(userID)
   logger.Error("failed to create form", "error", err)
   ```

## Common Patterns

1. Repository Pattern
   - Abstract data access
   - Domain-specific operations
   - Error handling
   - Example:
   ```go
   type Repository interface {
       Create(ctx context.Context, form *model.Form) error
       GetByID(ctx context.Context, id string) (*model.Form, error)
       GetByUserID(ctx context.Context, userID string) ([]*model.Form, error)
       Update(ctx context.Context, form *model.Form) error
       Delete(ctx context.Context, id string) error
   }
   ```

2. Event Publishing
   - Domain events
   - Event handlers
   - Error handling
   - Example:
   ```go
   type Publisher interface {
       Publish(ctx context.Context, event Event) error
   }
   ```

## Testing Guidelines

1. Unit Tests
   - Mock dependencies
   - Test error cases
   - Verify behavior
   - Example:
   ```go
   func TestService_CreateForm(t *testing.T) {
       mockRepo := &MockRepository{}
       mockPublisher := &MockPublisher{}
       mockLogger := &MockLogger{}
       service := NewService(mockRepo, mockPublisher, mockLogger)
       // Test implementation
   }
   ```

2. Integration Tests
   - Use test database
   - Test full flow
   - Clean up resources
   - Example:
   ```go
   func TestService_Integration(t *testing.T) {
       db := setupTestDB(t)
       defer db.Close()
       // Test implementation
   }
   ```

## Service Dependencies

1. Domain Services
   - Form service
   - User service
   - Submission service
   - Template service

2. Infrastructure
   - Database
   - Cache
   - File storage
   - External services

3. Cross-Cutting Concerns
   - Logging
   - Metrics
   - Error handling
   - Configuration

## Service Implementation

1. Constructor Pattern
   - NewService function
   - Dependency injection
   - Configuration validation
   - Error handling

2. Method Implementation
   - Clear responsibility
   - Error handling
   - Input validation
   - Proper logging

3. Error Handling
   - Use domain errors
   - Provide context
   - Handle all cases
   - Log appropriately

4. Logging
   - Structured logging
   - Context inclusion
   - Appropriate levels
   - Clear messages

## Performance Considerations

1. Caching
   - Cache expensive operations
   - Use appropriate TTL
   - Handle cache misses
   - Monitor cache usage

2. Database Operations
   - Use transactions
   - Optimize queries
   - Handle timeouts
   - Monitor performance

3. External Services
   - Handle timeouts
   - Implement retries
   - Monitor performance
   - Handle failures

## Security Guidelines

1. Input Validation
   - Validate all input
   - Use domain rules
   - Handle edge cases
   - Follow security guidelines

2. Error Handling
   - Don't expose internals
   - Use domain errors
   - Log appropriately
   - Follow security guidelines

3. Access Control
   - Check permissions
   - Validate access
   - Handle unauthorized
   - Follow security guidelines
