---
description: 
globs: 
alwaysApply: true
---
# Error Handling Guidelines

## Overview
This project implements a comprehensive error handling system for consistent error management across all layers.

## Core Error System

### DomainError Structure
```go
type DomainError struct {
    Code    ErrorCode
    Message string
    Err     error
    Context map[string]any
}
```

### Error Codes
```go
const (
    // Validation errors
    ErrCodeValidation    ErrorCode = "VALIDATION_ERROR"
    ErrCodeRequired      ErrorCode = "REQUIRED_FIELD"
    ErrCodeInvalid       ErrorCode = "INVALID_VALUE"
    
    // Authentication errors
    ErrCodeUnauthorized  ErrorCode = "UNAUTHORIZED"
    ErrCodeForbidden     ErrorCode = "FORBIDDEN"
    
    // Resource errors
    ErrCodeNotFound      ErrorCode = "NOT_FOUND"
    ErrCodeConflict      ErrorCode = "CONFLICT"
    ErrCodeServerError   ErrorCode = "SERVER_ERROR"
)
```

## Error Creation Patterns

### Standard Errors (simple cases)
```go
var (
    ErrFormTitleRequired = errors.New("form title is required")
    ErrFormNotFound = errors.New("form not found")
)

// Inline errors
if f.Title == "" {
    return errors.New("title is required")
}
```

### Domain Errors (complex cases)
```go
// Domain error with context
err := domainerrors.New(domainerrors.ErrCodeValidation, "invalid form data", nil).
    WithContext("form_id", formID).
    WithContext("field", "title")

// Wrapping errors
err := domainerrors.Wrap(originalErr, domainerrors.ErrCodeValidation, "form validation failed")
```

## Error Handling Patterns

### Service Layer
```go
func (s *FormService) CreateForm(ctx context.Context, req *CreateFormRequest) (*Form, error) {
    // Validate input
    if err := req.Validate(); err != nil {
        return nil, domainerrors.Wrap(err, domainerrors.ErrCodeValidation, "invalid form data")
    }

    // Create form
    form, err := s.repo.Create(ctx, req)
    if err != nil {
        return nil, domainerrors.Wrap(err, domainerrors.ErrCodeServerError, "failed to create form")
    }

    return form, nil
}
```

### Handler Error Response
```go
func (h *FormHandler) handleFormCreate(c echo.Context) error {
    if err != nil {
        h.Logger.Error("failed to create form", "error", err)
        
        // Check for specific validation errors
        switch {
        case errors.Is(err, model.ErrFormTitleRequired):
            return response.ErrorResponse(c, http.StatusBadRequest, "Form title is required")
        default:
            return response.ErrorResponse(c, http.StatusInternalServerError, "Failed to create form")
        }
    }
    
    return response.Success(c, map[string]string{
        "form_id": form.ID,
        "redirect": fmt.Sprintf("/forms/%s/edit", form.ID),
    })
}
```

## Validation Error Patterns

### Request Validation
```go
type CreateFormRequest struct {
    Title       string `json:"title" validate:"required,min=3,max=100"`
    Description string `json:"description" validate:"max=500"`
    Schema      JSON   `json:"schema" validate:"required"`
}

func (req *CreateFormRequest) Validate() error {
    if req.Title == "" {
        return errors.New("title is required")
    }
    if len(req.Title) < 3 {
        return errors.New("title must be at least 3 characters")
    }
    return nil
}
```

### Model Validation
```go
func (f *Form) Validate() error {
    if f.Title == "" {
        return errors.New("form title is required")
    }
    if len(f.Title) < MinTitleLength {
        return errors.New("title too short")
    }
    return f.validateSchema()
}
```

## Error Response Format

### Standardized API Error Response
All API errors now use the standardized response format:

```json
{
  "success": false,
  "message": "Error message here",
  "data": {
    "errors": {
      "field_name": ["Field-specific error message"]
    }
  }
}
```

### Handler Error Response Implementation
```go
func (h *Handler) handleError(c echo.Context, err error) error {
    var domainErr *errors.DomainError
    if errors.As(err, &domainErr) {
        // Create field-specific errors if available
        if len(domainErr.Context) > 0 {
            fieldErrors := make(map[string][]string)
            for k, v := range domainErr.Context {
                fieldErrors[k] = []string{fmt.Sprint(v)}
            }
            
            return response.ErrorResponse(c, getStatusCode(domainErr.Code), domainErr.Message)
        }
        
        return response.ErrorResponse(c, getStatusCode(domainErr.Code), domainErr.Message)
    }
    
    // Handle unknown errors
    return response.ErrorResponse(c, http.StatusInternalServerError, "Internal server error")
}
```

## Common Patterns

### Error Type Checking
```go
// Check for specific error types
if errors.Is(err, user.ErrUserExists) {
    return response.ErrorResponse(c, http.StatusBadRequest, "This email is already registered")
}

// Check for domain errors
var domainErr *errors.DomainError
if errors.As(err, &domainErr) {
    return response.ErrorResponse(c, getStatusCode(domainErr.Code), domainErr.Message)
}
```

## Best Practices

1. **Error Type Selection**
   - Use standard `errors.New()` for simple validation errors
   - Use `domainerrors.New()` for complex errors with context
   - Use `domainerrors.Wrap()` when wrapping existing errors

2. **Error Handling**
   - Handle errors at appropriate level
   - Log errors with context
   - Maintain error chain
   - Clean up resources

3. **Error Response**
   - Use consistent format
   - Include error details
   - Set appropriate status codes
   - Handle all error types

4. **Error Logging**
   - Log at appropriate level
   - Include error context
   - Add request details
   - Maintain error chain
