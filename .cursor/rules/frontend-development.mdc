---
description: 
globs: *.ts,*.css,*.js,src/**/*
alwaysApply: false
---
# Frontend Development Guidelines

## Overview
The frontend is built using vanilla TypeScript with templ templates, following a modern modular architecture with path mapping, service separation, and clean dependency management. The codebase has been refactored to follow enterprise-grade patterns.

## Core Technologies

1. **TypeScript**
   - Strict type checking enabled
   - Interface definitions and type guards
   - Utility types and generics
   - Path mapping for clean imports

2. **Vanilla TypeScript (No React)**
   - Modular TypeScript files with clear separation
   - DOM manipulation with type safety
   - Event handling with proper cleanup
   - Form validation with real-time feedback

3. **Templ Templates**
   - Server-side HTML templates
   - Type-safe template rendering
   - Component-based structure
   - Template inheritance

4. **Styling**
   - CSS modules for component isolation
   - PostCSS processing with autoprefixer
   - Responsive design principles
   - Design system consistency

5. **Build Tools**
   - Vite for development and building
   - ESLint for code quality
   - Prettier for formatting
   - TypeScript compiler with strict mode

## Project Structure

```
src/
├── js/                    # TypeScript source files
│   ├── core/             # Core application functionality
│   │   ├── config/       # Configuration files
│   │   ├── errors/       # Error classes and handling
│   │   ├── http-client.ts # HTTP client utilities
│   │   └── logger.ts     # Logging utilities
│   ├── features/         # Feature-based organization
│   │   ├── auth/         # Authentication feature
│   │   │   ├── login.ts
│   │   │   └── signup.ts
│   │   └── forms/        # Forms feature (main functionality)
│   │       ├── components/ # UI components
│   │       ├── handlers/   # Event and request handlers
│   │       ├── services/   # Business logic services
│   │       ├── state/      # State management
│   │       ├── validation/ # Form validation logic
│   │       └── index.ts    # Feature entry point
│   ├── pages/            # Page-level components
│   │   ├── dashboard.ts
│   │   ├── form-builder.ts
│   │   ├── login.ts
│   │   └── main.ts
│   └── shared/           # Shared utilities and types
│       ├── types/        # TypeScript type definitions
│       └── utils/        # Utility functions
├── css/                  # Stylesheets
│   ├── base/            # Base styles
│   ├── components/      # Component styles
│   ├── dashboard/       # Dashboard styles
│   ├── layouts/         # Layout styles
│   ├── pages/           # Page-specific styles
│   ├── themes/          # Theme styles
│   └── utils/           # Utility styles
└── types/               # TypeScript type definitions
```

## Import Standards

### Path Mapping
Use path mapping for all imports to ensure consistency and maintainability:

```typescript
// ✅ Correct - Use path mapping
import { FormBuilderError } from "@/core/errors/form-builder-error";
import { HttpClient } from "@/core/http-client";
import { FormService } from "@/features/forms/services/form-service";
import { dom } from "@/shared/utils/dom-utils";
import type { FormConfig } from "@/shared/types/form-types";

// ❌ Avoid - Relative imports
import { FormBuilderError } from "../../../core/errors/form-builder-error";
import { FormService } from "../services/form-service";
```

### Path Mapping Configuration
- `@/core/*` - Core application functionality
- `@/features/*` - Feature-specific code
- `@/shared/*` - Shared utilities and types
- `@/pages/*` - Page-level components

## Service Architecture

### Service Separation Pattern
Services are separated by responsibility for better maintainability:

```typescript
// FormApiService - HTTP operations only
export class FormApiService {
  async getSchema(formId: string): Promise<FormSchema> { /* ... */ }
  async saveSchema(formId: string, schema: any): Promise<any> { /* ... */ }
  async deleteForm(formId: string): Promise<void> { /* ... */ }
}

// FormUIService - DOM manipulation only
export class FormUIService {
  initializeFormDeletionHandlers(callback: (formId: string) => Promise<void>): void { /* ... */ }
  updateFormCard(formId: string, updates: any): void { /* ... */ }
  showSuccess(message: string): void { /* ... */ }
}

// FormService - Orchestration (facade pattern)
export class FormService {
  private apiService: FormApiService;
  private uiService: FormUIService;
  
  async updateFormDetails(formId: string, details: any): Promise<void> {
    await this.apiService.updateFormDetails(formId, details);
    this.uiService.updateFormCard(formId, details);
    this.uiService.showSuccess("Form updated successfully");
  }
}
```

### State Management
Use proper state management instead of global variables:

```typescript
// ✅ Correct - State management class
export class FormState {
  private state = new Map<string, any>();
  
  set(key: string, value: any): void {
    this.state.set(key, value);
  }
  
  get<T>(key: string): T | undefined {
    return this.state.get(key) as T | undefined;
  }
}

// ❌ Avoid - Global window assignments
window.formBuilder = builder;
window.formBuilderInstance = typedBuilder;
```

## HTTP Client Standards

### Consistent HTTP Operations
Use the centralized HttpClient for all HTTP operations:

```typescript
// ✅ Correct - Use HttpClient
const response = await HttpClient.get(url);
const response = await HttpClient.post(url, data);
const response = await HttpClient.put(url, data);
const response = await HttpClient.delete(url);

// ❌ Avoid - Direct fetch calls
const response = await fetch(url, { /* ... */ });
```

### Error Handling
Implement consistent error handling patterns:

```typescript
try {
  const response = await HttpClient.get(url);
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  return await response.json();
} catch (error) {
  console.error("API request failed:", error);
  throw new FormBuilderError(
    "Failed to fetch data",
    "Unable to load data. Please try again."
  );
}
```

## Build System

### Vite Configuration
- **Development**: Hot Module Replacement (HMR) with WebSocket
- **Production**: Asset optimization and minification
- **TypeScript**: ESNext target for modern browsers
- **CSS**: PostCSS processing with autoprefixer
- **Assets**: Automatic handling of fonts, images, and other static files
- **Path Mapping**: Configured in both tsconfig.json and vite.config.ts

### Development Mode
- Assets served from Vite dev server at `http://localhost:3000`
- Hot Module Replacement (HMR) for instant updates
- Source maps for debugging
- Proxy configuration for API requests
- Fast refresh for TypeScript files

### Production Build
- Assets built to `dist/` directory
- CSS files in `dist/assets/css/`
- JavaScript files in `dist/assets/js/`
- Fonts and images in `dist/assets/`
- Manifest file for asset versioning
- Console and debugger statements removed

## Component Patterns

### TypeScript Modules
```typescript
// Modular TypeScript files with proper imports
export class FormHandler {
    private form: HTMLFormElement;
    
    constructor(formId: string) {
        this.form = document.getElementById(formId) as HTMLFormElement;
        this.setupListeners();
    }
    
    private setupListeners(): void {
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
    }
    
    private async handleSubmit(event: Event): Promise<void> {
        // Form submission logic
    }
}
```

### Event Handling
```typescript
// Event-driven architecture with proper cleanup
class EventManager {
    private listeners: Map<string, Function[]> = new Map();
    
    on(event: string, callback: Function): void {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event)!.push(callback);
    }
    
    emit(event: string, data?: any): void {
        const callbacks = this.listeners.get(event) || [];
        callbacks.forEach(callback => callback(data));
    }
    
    off(event: string, callback: Function): void {
        const callbacks = this.listeners.get(event) || [];
        const index = callbacks.indexOf(callback);
        if (index > -1) {
            callbacks.splice(index, 1);
        }
    }
}
```

## State Management

### Local State
- Module-level state management
- Event-driven state updates
- DOM state synchronization
- Form state handling

### Server State
- API service modules with proper error handling
- Request/response caching strategies
- Loading states and user feedback
- Optimistic updates where appropriate

### Form State
- Real-time validation with immediate feedback
- Error display and success indicators
- Form reset functionality
- State persistence where needed

## API Integration

### API Client
```typescript
// Type-safe API service using HttpClient
export class FormService {
    private apiService: FormApiService;
    
    constructor() {
        this.apiService = FormApiService.getInstance();
    }
    
    async createForm(data: FormData): Promise<Form> {
        return this.apiService.createForm(data);
    }
}
```

### Authentication
- CSRF token handling through HttpClient
- Session management with proper security
- Protected route handling
- Comprehensive error handling

### Error Handling
- Structured error responses with user-friendly messages
- Proper error logging for debugging
- Graceful degradation for network issues
- Consistent error display patterns

## Validation

### Client-Side Validation
```typescript
// Validation with proper error handling
export class ValidationHandler {
    static async validateFormSubmission(
        form: HTMLFormElement,
        validationType: string
    ): Promise<boolean> {
        // Validation logic with proper error handling
    }
}
```

### Real-Time Validation
- Field-level validation with immediate feedback
- Error display and success indicators
- Validation state management
- Performance optimization with debouncing

## Best Practices

### Code Organization
1. **Feature-based structure** - Organize by features, not types
2. **Service separation** - Separate API, UI, and business logic
3. **Path mapping** - Use consistent import paths
4. **State management** - Avoid global variables

### Development Practices
1. **TypeScript strict mode** - Enable all strict checks
2. **ESLint rules** - Follow linting guidelines
3. **Prettier formatting** - Maintain consistent code style
4. **Testing** - Write tests for critical functionality

### Performance
1. **Code splitting** - Use dynamic imports for large modules
2. **Asset optimization** - Optimize images and fonts
3. **Caching strategies** - Implement proper caching
4. **Bundle analysis** - Monitor bundle sizes

### Security
1. **CSRF protection** - Use tokens for all state-changing requests
2. **Input sanitization** - Sanitize all user inputs
3. **XSS prevention** - Use proper escaping and validation
4. **Secure headers** - Implement security headers
